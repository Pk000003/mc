%Linearblockcode
clc;
clear all;
close all;
n=input('Enter n:');
k=input('Enter k:');
d=input('Enter data:');
G=input('Enter generator matrix:');
c=d*G;
C=rem(c,2);
disp('Data is :');
disp(d);
disp('Generator matrix is:');
disp(G);
disp('Code is:');
disp(C);
%Decoding of LBC
p=input('Enter parity matrix:');
h=horzcat(p.',eye(n-k));
ec1=vertcat(zeros(1,n), eye(n));
ec2=vertcat(zeros(1,n-k),h.');
disp('ERROR DECODING TABLE:');
ec=horzcat(ec1,ec2);
disp(ec);
r=input('Enter the received message:');
s=mod(r*h.',2);
disp('SYNDROME IS (S):');
disp(s);
if s==zeros(1,n-k)
disp('NO ERROR IN RECEIVED MESSAGE');
else
disp('ERROR IN BIT');
d=find(ismember (ec2, s, 'rows')); disp(d-1);
r(d-1)=(r(d-1)+1);
disp('CORRECTED CODEWORD IS:');
R=rem(r, 2);
disp(R);
end

%Enter n:7
%Enter k:4
%Enter data: [1 1 0 0]
%Enter generator matrix: [1,0,0,0,1,1,0;0,1,0,0,0,1,1;0,0,1,0,1,1,1;0,0,0,1,1,0,1]
%enter parity: [1,1,0;0,1,1;1,1,1;1,0,1]
%Enter the received message:[0111101]
*******************************************************************************************************************************
%Huffman
clc;
clear all;
close all;

symbols = input('Enter the symbols (as a vector): ');
prob = input('Enter the Probabilities (as a vector): ');

[dict, avglen] = huffmandict(symbols, prob);

temp = dict;
for i = 1:length(temp)
    temp{i,2} = num2str(temp{i,2});
end

disp('Huffman Dictionary:');
disp(temp);

actualsig = randsrc(100, 1, [symbols; prob]);

encoded = huffmanenco(actualsig, dict);
decoded = huffmandeco(encoded, dict);

disp('ENCODED Huffman code:');
disp(encoded');

disp('DECODED Huffman code:');
disp(decoded');

%Enter the symbols:[1 2 3 4 5]
%Enter the Probabilities:[0.4 0.2 0.2 0.1 0.1]
****************************************************************************************************************
%Entropy
clc;
clear all;
close all;

for i = 1:2
    px(i) = input("Enter P(xi) = ");
end

py = [0 0];
pygx = [0 0; 0 0];

for i = 1:2
    for j = 1:2
        pygx(i,j) = input("Enter P(yj/xi) = ");
    end
end

for i = 1:2
    for j = 1:2
        Py = px(j) * pygx(j,i);
        py(i) = py(i) + Py;
    end
end

hx = 0;
for i = 1:2
    h = px(i) * (log(1/px(i)) / log(2));
    hx = hx + h;
end

hy = 0;
for i = 1:2
    y = py(i) * (log(1/py(i)) / log(2));
    hy = hy + y;
end

for i = 1:2
    for j = 1:2
        pxy(i,j) = pygx(j,i) * px(i);
    end
end

Hygx = 0;
for i = 1:2
    for j = 1:2
        hygx = pxy(i,j) * (log(1/pygx(j,i)) / log(2));
        Hygx = Hygx + hygx;
    end
end

Hxy = hx + Hygx;
lxy = hy - Hygx;

disp("P(x)");
disp(px);
disp("P(y/x)");
disp(pygx);
disp("P(y)");
disp(py);
disp("H(x)");
disp(hx);
disp("H(y)");
disp(hy);
disp("P(x,y)");
disp(pxy);
disp("H(y|x)");
disp(Hygx);
disp("I(x;y)");
disp(lxy);

Hx = 0;
pxv = 0:0.01:1;
for i = 1:length(pxv)
    q = 1 - pxv(i);
    if pxv(i) == 0 || pxv(i) == 1
        Hx(i) = 0;
    else
        Hx(i) = -pxv(i)*log2(pxv(i)) - q*log2(q);
    end
end

plot(pxv, Hx);
grid on;
xlabel("Probability p(x)");
ylabel("Entropy H(x)");
title("Binary Entropy Function");


% enter thses values 
% P(xi) = 0.5
%Enter P(xi) = 0.5
%Enter P(yj/xi) = 0.4
%Enter P(yj/xi) = 0.6
%Enter P(yj/xi) = 0.4 
****************************************************************************************************
%randomprocess

clc;
clear all;
close all;

n = 1000;               % num of random values from Gaussian distribution
mu = 0;                 % mean
sigma = 1;              % standard deviation

y = normrnd(mu, sigma, 1, n);   


[Gy, f] = periodogram(y);        % find PSD


[Ry, lags] = xcorr(y, 'normalized');   % autocorrelation using xcorr


figure
subplot(1,2,1)
plot(f, Gy, 'b', 'LineWidth', 1.2)
xlabel('Frequency Samples')
ylabel('Power')
title('PSD')
grid on

subplot(1,2,2)
stem(lags, Ry, 'r', 'filled')
xlabel('Time Shift')
ylabel('Autocorrelation')
title('Autocorrelation')
grid on
*******************************************************************************************
%MaryPSK

% M-PSK Modulation and Performance over AWGN
clear all;
close all;
clc;

% Eb/No range (in dB)
Eb_NO_db = 0:0.5:35;

% M values
M_4 = 4;
M_8 = 8;
M_16 = 16;
M_32 = 32;

% Theoretical BER using MATLAB's built-in function
BER_4 = berawgn(Eb_NO_db, 'psk', M_4, 'nondiff');
BER_8 = berawgn(Eb_NO_db, 'psk', M_8, 'nondiff');
BER_16 = berawgn(Eb_NO_db, 'psk', M_16, 'nondiff');
BER_32 = berawgn(Eb_NO_db, 'psk', M_32, 'nondiff');

% Plot BER vs Eb/No
figure(1);
semilogy(Eb_NO_db, BER_4, 'b', 'LineWidth', 1.5); hold on;
semilogy(Eb_NO_db, BER_8, 'r', 'LineWidth', 1.5);
semilogy(Eb_NO_db, BER_16, 'k', 'LineWidth', 1.5);
semilogy(Eb_NO_db, BER_32, 'g', 'LineWidth', 1.5);
grid on;
axis([0 35 1e-5 1]);
legend('QPSK (4-PSK)', '8-PSK', '16-PSK', '32-PSK');
xlabel('SNR (dB)');
ylabel('Bit Error Rate (BER)');
title('M-PSK Modulation over Gaussian Noise');

%% ---------------- Constellation Plot Section ---------------- %%
% Example: 8-PSK constellation
M = 8;                          % Modulation order
N = 1000;                       % Number of symbols
data = randi([0 M-1], N, 1);    % Random input data
modSig = pskmod(data, M);       % PSK modulation

% Add AWGN noise
SNR = 15;                      % Eb/No in dB for scatter plot
rxSig = awgn(modSig, SNR, 'measured');

% Plot transmitted (ideal) constellation
figure(2);
subplot(1,2,1);
scatterplot(modSig);
title(['Ideal ', num2str(M), '-PSK Constellation']);
grid on;

% Plot received (noisy) constellation
subplot(1,2,2);
scatterplot(rxSig);
title([num2str(M), '-PSK Constellation with AWGN (Eb/No = ', num2str(EbNo), ' dB)']);
grid on;
**************************************************************************************************************
%M_QAM

clear all;
close all;
clc;

% M-ary QAM Modulation over Gaussian Noise

Eb_NO_dB = 0:0.5:35;    % Eb/No range (in dB)

% Modulation orders
M_4  = 4;
M_16 = 16;
M_64 = 64;

% Theoretical BER for QAM (non-differential, coherent detection)
BER_4  = berawgn(Eb_NO_dB, 'qam', M_4, 'nondiff');
BER_16 = berawgn(Eb_NO_dB, 'qam', M_16, 'nondiff');
BER_64 = berawgn(Eb_NO_dB, 'qam', M_64, 'nondiff');

% Plot BER curves
figure(1);
semilogy(Eb_NO_dB, BER_4, 'b', 'LineWidth', 1.5);
hold on;
semilogy(Eb_NO_dB, BER_16, 'r', 'LineWidth', 1.5);
semilogy(Eb_NO_dB, BER_64, 'g', 'LineWidth', 1.5);
grid on;

axis([0 35 1e-5 1]);
legend('4-QAM (QPSK)', '16-QAM', '64-QAM');
xlabel('Eb/No (dB)');
ylabel('Bit Error Rate (BER)');
title('M-QAM Modulation over Gaussian Noise');
***************************************************************************
%M_QAM_Constalation
clc;
clear all;
close all;
% Running the program for three values of M
M_values = [64]; % Use array instead of commas
SNR = 10; % Signal-to-noise ratio
for i = 1:length(M_values)
 M = M_values(i);
 x = 0:M-1; % Input symbols
 % QAM Modulation
 y = qammod(x, M); % Syntax: qammod(x, M)
 % Add AWGN noise
 yn = awgn(y, SNR, 'measured');
 % Display constellation
 figure;
 scatterplot(y);
 title(['Constellation Diagram for ', num2str(M), '-QAM (Without Noise)']);
 figure;
 scatterplot(yn);
 title(['Constellation Diagram for ', num2str(M), '-QAM (With AWGN, SNR=',
num2str(SNR), ' dB)']);
end
**************************************************************************************************************************************************************************************************************************************************************************************************************************************
